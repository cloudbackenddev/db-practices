# Database Standards and Guidelines for DBML Generation

This document contains technical standards and best practices that LLM models should follow when generating DBML from business requirements.

---

## ðŸ¤– **LLM PROCESSING INSTRUCTIONS**

### **MANDATORY Standards (Must be applied):**
- [ ] Use application-generated TSID for business entities
- [ ] Apply proper naming conventions based on database type
- [ ] Create indexes based on access patterns and frequency
- [ ] Implement audit fields (created_at, updated_at, etc.)
- [ ] Use database-specific data types and features

### **RECOMMENDED Standards (Apply when applicable):**
- [ ] Optimize for specified application framework (JPA/ORM)
- [ ] Implement soft delete pattern when needed
- [ ] Add security considerations (encryption, compliance)
- [ ] Use JSON storage appropriately (not by default)

---

## ID Generation Strategy

### **Business Entity Tables (users, orders, products):**
```
Primary Key Strategy:
- Internal ID: BIGINT with sequence (for joins/foreign keys)
- Public ID: TSID (for APIs/external use)
- Generation: Application-generated (not database-generated)

PostgreSQL Implementation:
- id: BIGINT DEFAULT nextval('table_name_id_seq') PRIMARY KEY
- public_id: VARCHAR(26) NOT NULL UNIQUE (for TSID)

Oracle Implementation:
- id: NUMBER(19) DEFAULT table_name_seq.nextval PRIMARY KEY
- public_id: VARCHAR2(26) NOT NULL UNIQUE (for TSID)

Why Application-Generated TSID?
- Time-ordered (better clustering and performance)
- Better batch insert performance than UUIDs
- No database round-trips for ID generation
- Supports distributed systems
- Works well with JPA/ORM frameworks
- Shorter than UUIDs (26 vs 36 characters)
```

### **Reference/Lookup Tables (countries, roles, statuses):**
```
Simple auto-increment acceptable:
- PostgreSQL: id SERIAL PRIMARY KEY
- Oracle: id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY
```

### **TSID Standard:**
```
TSID (Time-Sorted ID):
- Format: 01HN2K8G7QRXM9VWPZ3F4T5Y6B (26 chars)
- Time-ordered (better clustering and performance)
- Lexicographically sortable
- Globally unique across distributed systems
- More compact than UUIDs
- Better database performance than random UUIDs
```

---

## Naming Conventions

### **PostgreSQL Standards:**
```
Tables: snake_case, singular (user, order, product)
Columns: snake_case (first_name, created_at, is_active)
Primary Keys: id (bigint)
Foreign Keys: {table}_id (user_id, product_id)
Booleans: is_{condition} (is_active, is_deleted)
Timestamps: {action}_at (created_at, updated_at)
Indexes: idx_{table}_{columns} (idx_users_email)
Sequences: {table}_id_seq (users_id_seq)
```

### **Oracle Standards:**
```
Tables: UPPER_CASE, singular (USER, ORDER, PRODUCT)
Columns: UPPER_CASE (FIRST_NAME, CREATED_AT, IS_ACTIVE)
Primary Keys: ID (NUMBER(19))
Foreign Keys: {TABLE}_ID (USER_ID, PRODUCT_ID)
Booleans: IS_{CONDITION} (IS_ACTIVE, IS_DELETED)
Timestamps: {ACTION}_AT (CREATED_AT, UPDATED_AT)
Indexes: IDX_{TABLE}_{COLUMNS} (IDX_USERS_EMAIL)
Sequences: {TABLE}_ID_SEQ (USERS_ID_SEQ)
```

### **JPA/ORM Mapping Considerations:**
```
Database to Java Mapping:
- Database: snake_case â†’ Java: camelCase
- Example: first_name â†’ firstName, created_at â†’ createdAt

Table Design for JPA:
- Single-column primary keys (avoid composite keys)
- Foreign key naming supports @JoinColumn mapping
- Junction tables: {entity1}_{entity2} (user_roles, order_items)
- Avoid reserved keywords that conflict with JPA
```

---

## Standard Fields

### **Business Entity Tables:**

#### **PostgreSQL:**
```sql
-- Required fields for all business entities
id BIGINT DEFAULT nextval('table_name_id_seq') PRIMARY KEY,
public_id VARCHAR(26) NOT NULL UNIQUE,
created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,

-- Recommended audit fields
created_by BIGINT REFERENCES users(id),
updated_by BIGINT REFERENCES users(id),
version INTEGER DEFAULT 1,

-- Soft delete pattern (when needed)
is_deleted BOOLEAN DEFAULT false,
deleted_at TIMESTAMPTZ,
deleted_by BIGINT REFERENCES users(id)
```

#### **Oracle:**
```sql
-- Required fields for all business entities
ID NUMBER(19) DEFAULT table_name_seq.nextval PRIMARY KEY,
PUBLIC_ID VARCHAR2(26) NOT NULL UNIQUE,
CREATED_AT TIMESTAMP WITH TIME ZONE DEFAULT SYSTIMESTAMP,
UPDATED_AT TIMESTAMP WITH TIME ZONE DEFAULT SYSTIMESTAMP,

-- Recommended audit fields
CREATED_BY NUMBER(19) REFERENCES USERS(ID),
UPDATED_BY NUMBER(19) REFERENCES USERS(ID),
VERSION NUMBER(10) DEFAULT 1,

-- Soft delete pattern (when needed)
IS_DELETED NUMBER(1) DEFAULT 0 CHECK (IS_DELETED IN (0,1)),
DELETED_AT TIMESTAMP WITH TIME ZONE,
DELETED_BY NUMBER(19) REFERENCES USERS(ID)
```

### **Reference/Lookup Tables:**

#### **PostgreSQL:**
```sql
id SERIAL PRIMARY KEY,
name VARCHAR(100) NOT NULL,
code VARCHAR(20) UNIQUE,
is_active BOOLEAN DEFAULT true,
sort_order INTEGER,
created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
```

#### **Oracle:**
```sql
ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
NAME VARCHAR2(100) NOT NULL,
CODE VARCHAR2(20) UNIQUE,
IS_ACTIVE NUMBER(1) DEFAULT 1 CHECK (IS_ACTIVE IN (0,1)),
SORT_ORDER NUMBER(10),
CREATED_AT TIMESTAMP WITH TIME ZONE DEFAULT SYSTIMESTAMP
```

---

## Data Types Standards

### **PostgreSQL Specific:**
```
Strings: VARCHAR(n) with appropriate limits
Numbers: DECIMAL for money, INTEGER for counts, BIGINT for IDs
Dates: TIMESTAMPTZ for all datetime fields
Booleans: BOOLEAN with meaningful names (is_active, not active)
JSON: JSONB (better performance and indexing than JSON)
IDs: VARCHAR(26) for TSID public IDs
Arrays: Avoid PostgreSQL arrays, prefer junction tables
Money: DECIMAL(19,4) for currency amounts
```

### **Oracle Specific:**
```
Strings: VARCHAR2(n) with appropriate limits
Numbers: NUMBER for decimals, INTEGER for counts, NUMBER(19) for IDs
Dates: TIMESTAMP WITH TIME ZONE for all datetime fields
Booleans: NUMBER(1) CHECK (value IN (0,1))
JSON: JSON datatype (21c+) or CLOB with constraints (older)
IDs: VARCHAR2(26) for TSID public IDs
Money: NUMBER(19,4) for currency amounts
LOBs: BLOB for binary data, CLOB for large text
```

---

## JSON vs Normalized Decision Matrix

### **Use JSON Storage For:**
- Variable attributes that differ by category/type
- User preferences and settings
- Metadata and flexible properties
- Product specifications that vary by category
- Configuration data with unknown structure
- Audit trail details and change logs

### **Use Normalized Tables For:**
- Relationships between entities
- Frequently queried and filtered fields
- Structured data with fixed schema
- Data requiring referential integrity
- Fields used in JOINs and complex queries
- Data requiring strong consistency

### **JSON Implementation:**

#### **PostgreSQL:**
```sql
-- Use JSONB for better performance
preferences JSONB,
metadata JSONB,

-- Create GIN indexes for JSON queries
CREATE INDEX idx_users_preferences ON users USING GIN (preferences);

-- Query examples
WHERE preferences @> '{"theme": "dark"}'
WHERE preferences->>'language' = 'en'
```

#### **Oracle:**
```sql
-- Use JSON datatype (21c+)
PREFERENCES JSON,
METADATA JSON,

-- Create function-based indexes
CREATE INDEX idx_users_prefs ON users (JSON_VALUE(preferences, '$.theme'));

-- Query examples
WHERE JSON_VALUE(preferences, '$.theme') = 'dark'
WHERE JSON_VALUE(preferences, '$.language') = 'en'
```

---

## Index Strategy

### **Index Priority Guide:**
```
CRITICAL (Must have - create first):
- Primary keys (automatic)
- Foreign keys (all FK columns)
- Unique constraints (business rules)
- Public ID lookups (API access)

HIGH (Performance essential):
- Frequently filtered columns (WHERE clauses)
- Authentication fields (email, username)
- Status/active flags with partial indexes
- Time-based queries (created_at, updated_at)

MEDIUM (Performance beneficial):
- Sorting columns (ORDER BY clauses)
- Join columns beyond foreign keys
- Composite indexes for common query patterns
- Range query columns (price, quantity)

LOW (Nice to have):
- JSON paths (specific use cases only)
- Text search columns (full-text search)
- Reporting-only queries
- Admin/infrequent operations
```

### **Access Pattern to Index Mapping:**
```
High Frequency (>100 queries/minute):
- Response time: <50ms
- Must have dedicated indexes (CRITICAL + HIGH priority)
- Consider read replicas for scaling

Medium Frequency (10-100 queries/minute):
- Response time: <200ms
- Shared indexes acceptable (MEDIUM priority)
- Monitor for optimization opportunities

Low Frequency (<10 queries/minute):
- Response time: <1000ms
- Can use existing indexes (LOW priority)
- Acceptable for table scans on small tables
```

### **Index Examples:**

#### **PostgreSQL:**
```sql
-- High frequency: User authentication
CREATE INDEX idx_users_email ON users(email) WHERE is_deleted = false;

-- High frequency: API lookups
CREATE INDEX idx_users_public_id ON users(public_id);

-- Medium frequency: Product search
CREATE INDEX idx_products_name_category ON products(category_id, name) WHERE is_active = true;

-- Low frequency: Reporting
CREATE INDEX idx_orders_created_at ON orders(created_at DESC);

-- JSON indexes
CREATE INDEX idx_users_preferences ON users USING GIN (preferences);
```

#### **Oracle:**
```sql
-- High frequency: User authentication
CREATE INDEX IDX_USERS_EMAIL ON USERS(EMAIL) WHERE IS_DELETED = 0;

-- High frequency: API lookups
CREATE INDEX IDX_USERS_PUBLIC_ID ON USERS(PUBLIC_ID);

-- Medium frequency: Product search
CREATE INDEX IDX_PRODUCTS_NAME_CAT ON PRODUCTS(CATEGORY_ID, NAME) WHERE IS_ACTIVE = 1;

-- JSON indexes
CREATE INDEX IDX_USERS_PREFS ON USERS (JSON_VALUE(PREFERENCES, '$.theme'));
```

---

## Security and Compliance Standards

### **Data Protection:**
```
PII Data Handling:
- Encrypt sensitive columns at rest
- Use separate tables for highly sensitive data
- Implement column-level security where needed

Audit Trail Requirements:
- created_at, updated_at for all business entities
- created_by, updated_by for user tracking
- version column for optimistic locking
- Separate audit tables for detailed change tracking

Soft Delete Pattern:
- is_deleted BOOLEAN DEFAULT false
- deleted_at TIMESTAMPTZ (when deleted)
- deleted_by BIGINT (who deleted)
- Use WHERE is_deleted = false in queries
```

### **Compliance Patterns:**

#### **GDPR Compliance:**
```sql
-- Right to be forgotten support
UPDATE users SET 
    is_deleted = true,
    deleted_at = CURRENT_TIMESTAMP,
    email = 'deleted_' || id || '@gdpr.local',
    first_name = 'DELETED',
    last_name = 'DELETED'
WHERE public_id = ?;
```

#### **Data Retention:**
```sql
-- Automatic cleanup after retention period
DELETE FROM audit_logs 
WHERE created_at < CURRENT_TIMESTAMP - INTERVAL '7 years';
```

---

## JPA/ORM Optimization Standards

### **Entity Design Patterns:**
```
Primary Keys:
- Single-column primary keys only
- Use BIGINT/NUMBER(19) for internal IDs
- Separate public_id column for API exposure

Relationship Design:
- Foreign keys named for @JoinColumn mapping
- Bidirectional relationships supported
- Junction tables for @ManyToMany

Query Optimization:
- All foreign keys indexed (prevents N+1 queries)
- Composite indexes for common JPQL patterns
- Lazy loading support through proper indexing
```

### **Batch Operation Support:**
```
Sequence Configuration:
- PostgreSQL: Use custom sequences with appropriate increment
- Oracle: Set sequence cache size for bulk operations

Bulk Insert Optimization:
- Application-generated IDs (no DB round-trips)
- Minimal constraints during bulk operations
- Proper index strategy for bulk updates
```

---

## Enumerated Types

### **DBML Enum Creation:**
```
Create DBML enums for status and category fields:

enum account_status {
  ACTIVE
  SUSPENDED
  PENDING_DELETION
  INACTIVE
}

enum order_status {
  PENDING
  PAID
  PROCESSING
  SHIPPED
  DELIVERED
  CANCELLED
  REFUNDED
}

Benefits:
- Better schema documentation
- Database-level validation
- API documentation support
- Prevents invalid status values
```

---

## Documentation Standards

### **Table Documentation:**
```
All tables must have:
- Business purpose description
- Key business rules explained
- Relationship explanations
- Index purposes documented
- JSON storage decisions explained
```

### **Column Documentation:**
```
Document columns that:
- Have business significance
- Contain enumerated values
- Have validation rules
- Are used in complex calculations
- Store JSON data
```

### **Index Documentation:**
```
Document indexes with:
- Purpose and access pattern
- Frequency classification
- Performance requirements
- Maintenance considerations
```

---

**Standards Version:** 1.0.0  
**Last Updated:** 2025-01-22  
**Compatible with:** DBML Standards Guidelines v1.0.0